import io
import json
import os
import tempfile
import unittest

from verbatim.audio.settings import AUDIO_PARAMS
from verbatim.transcript.format.json import (
    TranscriptFormatter,
    TranscriptParser,
    read_utterances,
    save_utterances,
)
from verbatim.transcript.words import Utterance, Word

# =============================================================================
# Unit Tests
# =============================================================================


class TestTranscriptFormatter(unittest.TestCase):
    def test_open_close(self):
        """
        Verify that TranscriptFormatter.open and close correctly wrap the JSON
        transcript in a proper JSON object (i.e. with "utterances" array).
        """
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        output.write("TEST_CONTENT")  # Simulate content inserted between open and close
        formatter.close(output)
        content = output.getvalue()
        self.assertTrue(content.startswith('{\n  "utterances": [\n'))
        self.assertTrue(content.endswith("\n  ]\n}\n"))

    def test_format_utterance_with_words(self):
        """
        Test that format_utterance correctly writes an utterance (with words)
        into JSON. Checks that timestamps are converted from sample counts to
        seconds (using the configured sample rate) and that numerical rounding
        is performed as expected.
        """
        # Create a dummy utterance with one word.
        sr = AUDIO_PARAMS.sample_rate
        word = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=sr)
        utt = Utterance("utt1", "speaker1", 0, 2 * sr, "hello", [word])

        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt, output, with_words=True)
        formatter.close(output)
        output.seek(0)

        # Parse the written JSON and check the fields.
        data = json.load(output)
        self.assertIn("utterances", data)
        self.assertEqual(len(data["utterances"]), 1)
        utt_data = data["utterances"][0]
        self.assertEqual(utt_data["id"], "utt1")
        self.assertEqual(utt_data["speaker"], "speaker1")
        self.assertAlmostEqual(utt_data["start"], 0.0, places=5)
        self.assertAlmostEqual(utt_data["end"], 2.0, places=5)  # 2 * sr -> 2.0 sec
        self.assertEqual(utt_data["text"], "hello")
        # Check word details.
        self.assertIn("words", utt_data)
        self.assertEqual(len(utt_data["words"]), 1)
        word_data = utt_data["words"][0]
        self.assertEqual(word_data["text"], "hello")
        self.assertEqual(word_data["lang"], "en")
        self.assertAlmostEqual(word_data["prob"], 0.9876, places=4)
        self.assertAlmostEqual(word_data["start"], 0.0, places=5)
        self.assertAlmostEqual(word_data["end"], 1.0, places=5)  # sr -> 1.0 sec

    def test_format_utterance_without_words(self):
        """
        Test that setting with_words=False omits the "words" key in the
        output JSON.
        """
        sr = AUDIO_PARAMS.sample_rate
        word = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=sr)
        utt = Utterance("utt1", "speaker1", 0, 2 * sr, "hello", [word])
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt, output, with_words=False)
        formatter.close(output)
        output.seek(0)
        data = json.load(output)
        utt_data = data["utterances"][0]
        self.assertNotIn("words", utt_data)

    def test_multiple_utterances_formatting(self):
        """
        Verify that successive calls to format_utterance insert the necessary
        commas between utterance JSON objects.
        """
        sr = AUDIO_PARAMS.sample_rate
        word1 = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=sr)
        utt1 = Utterance("utt1", "speaker1", 0, 2 * sr, "hello", [word1])
        word2 = Word(word="world", lang="en", probability=0.95, start_ts=sr, end_ts=2 * sr)
        utt2 = Utterance("utt2", "speaker1", 2 * sr, 4 * sr, "world", [word2])
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt1, output)
        formatter.format_utterance(utt2, output)
        formatter.close(output)
        output.seek(0)
        data = json.load(output)
        self.assertEqual(len(data["utterances"]), 2)


class TestTranscriptParser(unittest.TestCase):
    def test_parse_single_utterance(self):
        """
        Provide a JSON transcript (as generated by TranscriptFormatter) and verify
        that TranscriptParser.parse reconstructs the Utterance (and Word) objects
        with proper conversion (i.e. seconds back to sample counts).
        """
        transcript_dict = {
            "utterances": [
                {
                    "id": "utt1",
                    "start": 0.0,
                    "end": 2.0,
                    "speaker": "speaker1",
                    "language": "en",
                    "text": "hello",
                    "words": [{"text": "hello", "lang": "en", "prob": 0.9876, "start": 0.0, "end": 1.0}],
                }
            ]
        }
        transcript_json = json.dumps(transcript_dict)
        input_io = io.StringIO(transcript_json)
        sr = AUDIO_PARAMS.sample_rate
        parser = TranscriptParser(sample_rate=sr)
        utterances = parser.parse(input_io)
        self.assertEqual(len(utterances), 1)
        utt = utterances[0]
        self.assertEqual(utt.utterance_id, "utt1")
        self.assertEqual(utt.speaker, "speaker1")
        self.assertEqual(utt.text, "hello")
        # Conversion: 2.0 seconds * sr = 2 * sr sample count
        self.assertEqual(utt.start_ts, 0)
        self.assertEqual(utt.end_ts, 2 * sr)
        self.assertEqual(len(utt.words), 1)
        word = utt.words[0]
        self.assertEqual(word.word, "hello")
        self.assertEqual(word.lang, "en")
        self.assertAlmostEqual(word.probability, 0.9876, places=4)
        # Conversion: 1.0 second * sr = sr sample count
        self.assertEqual(word.start_ts, 0)
        self.assertEqual(word.end_ts, sr)


class TestJsonTranscriptWriterIntegration(unittest.TestCase):
    def test_save_and_read_utterances(self):
        """
        End-to-end test: use save_utterances to write a transcript to a temporary
        file, then read it back with read_utterances. This verifies that the writer,
        formatter, and parser all cooperate to produce a round-trip accurate JSON transcript.
        """
        sr = AUDIO_PARAMS.sample_rate
        word = Word(word="world", lang="en", probability=0.95, start_ts=sr, end_ts=2 * sr)
        utt = Utterance("utt2", "speaker2", 0, 3 * sr, "hello world", [word])
        utterances = [utt]

        with tempfile.TemporaryDirectory() as tmpdir:
            # Note: save_utterances removes the extension and appends ".json"
            filepath = os.path.join(tmpdir, "test.json")
            save_utterances(filepath, utterances, None)
            # Now read the transcript back.
            read_utts = read_utterances(filepath)
            self.assertEqual(len(read_utts), 1)
            read_utt = read_utts[0]
            self.assertEqual(read_utt.utterance_id, "utt2")
            self.assertEqual(read_utt.speaker, "speaker2")
            self.assertEqual(read_utt.text, "hello world")
            self.assertEqual(read_utt.start_ts, 0)
            self.assertEqual(read_utt.end_ts, 48000)
            self.assertEqual(len(read_utt.words), 1)
            read_word = read_utt.words[0]
            self.assertEqual(read_word.word, "world")
            self.assertEqual(read_word.lang, "en")
            self.assertAlmostEqual(read_word.probability, 0.95, places=4)
            # The writer converts sample counts to seconds and back:
            self.assertEqual(read_word.start_ts, sr)
            self.assertEqual(read_word.end_ts, 2 * sr)


# =============================================================================
# Main entry point for unittest
# =============================================================================

if __name__ == "__main__":
    unittest.main()
