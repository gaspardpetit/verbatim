import io
import json
import os
import tempfile
import unittest

from verbatim.transcript.words import Word, Utterance

from verbatim.transcript.format.json import (
    TranscriptFormatter,
    TranscriptParser,
    save_utterances,
    read_utterances,
)

# =============================================================================
# Unit Tests
# =============================================================================

class TestTranscriptFormatter(unittest.TestCase):
    def test_open_close(self):
        """
        Verify that TranscriptFormatter.open and close correctly wrap the JSON
        transcript in a proper JSON object (i.e. with "utterances" array).
        """
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        output.write("TEST_CONTENT")  # Simulate content inserted between open and close
        formatter.close(output)
        content = output.getvalue()
        self.assertTrue(content.startswith('{\n  "utterances": [\n'))
        self.assertTrue(content.endswith("\n  ]\n}\n"))

    def test_format_utterance_with_words(self):
        """
        Test that format_utterance correctly writes an utterance (with words)
        into JSON. Checks that timestamps are converted from sample counts to
        seconds (using the fixed sample rate of 16000) and that numerical rounding
        is performed as expected.
        """
        # Create a dummy utterance with one word.
        word = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=16000)  # 0 sec to 1.0 sec
        utt = Utterance("utt1", "speaker1", 0, 32000, "hello", [word])  # 0 sec to 2.0 sec

        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt, output, with_words=True)
        formatter.close(output)
        output.seek(0)

        # Parse the written JSON and check the fields.
        data = json.load(output)
        self.assertIn("utterances", data)
        self.assertEqual(len(data["utterances"]), 1)
        utt_data = data["utterances"][0]
        self.assertEqual(utt_data["id"], "utt1")
        self.assertEqual(utt_data["speaker"], "speaker1")
        self.assertAlmostEqual(utt_data["start"], 0.0, places=5)
        self.assertAlmostEqual(utt_data["end"], 2.0, places=5)  # 32000/16000 = 2.0 sec
        self.assertEqual(utt_data["text"], "hello")
        # Check word details.
        self.assertIn("words", utt_data)
        self.assertEqual(len(utt_data["words"]), 1)
        word_data = utt_data["words"][0]
        self.assertEqual(word_data["text"], "hello")
        self.assertEqual(word_data["lang"], "en")
        self.assertAlmostEqual(word_data["prob"], 0.9876, places=4)
        self.assertAlmostEqual(word_data["start"], 0.0, places=5)
        self.assertAlmostEqual(word_data["end"], 1.0, places=5)  # 16000/16000 = 1.0 sec

    def test_format_utterance_without_words(self):
        """
        Test that setting with_words=False omits the "words" key in the
        output JSON.
        """
        word = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=16000)  # 0 sec to 1.0 sec
        utt = Utterance("utt1", "speaker1", 0, 32000, "hello", [word])
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt, output, with_words=False)
        formatter.close(output)
        output.seek(0)
        data = json.load(output)
        utt_data = data["utterances"][0]
        self.assertNotIn("words", utt_data)

    def test_multiple_utterances_formatting(self):
        """
        Verify that successive calls to format_utterance insert the necessary
        commas between utterance JSON objects.
        """
        word1 = Word(word="hello", lang="en", probability=0.9876, start_ts=0, end_ts=16000)
        utt1 = Utterance("utt1", "speaker1", 0, 32000, "hello", [word1])
        word2 = Word(word="world", lang="en", probability=0.95, start_ts=16000, end_ts=32000)
        utt2 = Utterance("utt2", "speaker1", 32000, 64000, "world", [word2])
        formatter = TranscriptFormatter()
        output = io.StringIO()
        formatter.open(output)
        formatter.format_utterance(utt1, output)
        formatter.format_utterance(utt2, output)
        formatter.close(output)
        output.seek(0)
        data = json.load(output)
        self.assertEqual(len(data["utterances"]), 2)


class TestTranscriptParser(unittest.TestCase):
    def test_parse_single_utterance(self):
        """
        Provide a JSON transcript (as generated by TranscriptFormatter) and verify
        that TranscriptParser.parse reconstructs the Utterance (and Word) objects
        with proper conversion (i.e. seconds back to sample counts).
        """
        transcript_dict = {
            "utterances": [
                {
                    "id": "utt1",
                    "start": 0.0,
                    "end": 2.0,
                    "speaker": "speaker1",
                    "language": "en",
                    "text": "hello",
                    "words": [
                        {
                            "text": "hello",
                            "lang": "en",
                            "prob": 0.9876,
                            "start": 0.0,
                            "end": 1.0
                        }
                    ]
                }
            ]
        }
        transcript_json = json.dumps(transcript_dict)
        input_io = io.StringIO(transcript_json)
        parser = TranscriptParser(sample_rate=16000)
        utterances = parser.parse(input_io)
        self.assertEqual(len(utterances), 1)
        utt = utterances[0]
        self.assertEqual(utt.utterance_id, "utt1")
        self.assertEqual(utt.speaker, "speaker1")
        self.assertEqual(utt.text, "hello")
        # Conversion: 2.0 seconds * 16000 = 32000 sample count
        self.assertEqual(utt.start_ts, 0)
        self.assertEqual(utt.end_ts, 32000)
        self.assertEqual(len(utt.words), 1)
        word = utt.words[0]
        self.assertEqual(word.word, "hello")
        self.assertEqual(word.lang, "en")
        self.assertAlmostEqual(word.probability, 0.9876, places=4)
        # Conversion: 1.0 second * 16000 = 16000 sample count
        self.assertEqual(word.start_ts, 0)
        self.assertEqual(word.end_ts, 16000)


class TestJsonTranscriptWriterIntegration(unittest.TestCase):
    def test_save_and_read_utterances(self):
        """
        End-to-end test: use save_utterances to write a transcript to a temporary
        file, then read it back with read_utterances. This verifies that the writer,
        formatter, and parser all cooperate to produce a round-trip accurate JSON transcript.
        """
        word = Word(word="world", lang="en", probability=0.95, start_ts=16000, end_ts=32000)  # word spans 1.0 to 2.0 seconds
        utt = Utterance("utt2", "speaker2", 0, 48000, "hello world", [word])  # 0 to 3.0 seconds
        utterances = [utt]

        with tempfile.TemporaryDirectory() as tmpdir:
            # Note: save_utterances removes the extension and appends ".json"
            filepath = os.path.join(tmpdir, "test.json")
            save_utterances(filepath, utterances, None)
            # Now read the transcript back.
            read_utts = read_utterances(filepath)
            self.assertEqual(len(read_utts), 1)
            read_utt = read_utts[0]
            self.assertEqual(read_utt.utterance_id, "utt2")
            self.assertEqual(read_utt.speaker, "speaker2")
            self.assertEqual(read_utt.text, "hello world")
            self.assertEqual(read_utt.start_ts, 0)
            self.assertEqual(read_utt.end_ts, 48000)
            self.assertEqual(len(read_utt.words), 1)
            read_word = read_utt.words[0]
            self.assertEqual(read_word.word, "world")
            self.assertEqual(read_word.lang, "en")
            self.assertAlmostEqual(read_word.probability, 0.95, places=4)
            # The writer converts sample counts to seconds and back:
            self.assertEqual(read_word.start_ts, 16000)  # 1.0 sec * 16000
            self.assertEqual(read_word.end_ts, 32000)      # 2.0 sec * 16000


# =============================================================================
# Main entry point for unittest
# =============================================================================

if __name__ == '__main__':
    unittest.main()
